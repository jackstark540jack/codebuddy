from flask import Flask, request, jsonify
from together import Together
import os
import re
from flask_cors import CORS
from dotenv import load_dotenv
import json
# Load environment variables
load_dotenv()

# Flask setup
app = Flask(__name__)
CORS(app)  # Enable CORS for all routes

# Initialize Together client
together_api_key = os.getenv("TOGETHER_API_KEY")
client = Together(api_key=together_api_key)

@app.route('/api/generate-task', methods=['POST'])
def generate_task():
    try:
        # Parse input data
        data = request.json
        subject = data.get('subject')
        difficulty = data.get('difficulty')

        # Define the prompt
        prompt = f"""Generate a coding challenge for {subject} at {difficulty} level. Include:
        - Title
        - Description
        - Starter code
        Format as JSON with the following structure:
        {{
          "title": "Challenge title",
          "description": "Detailed description",
          "difficulty": "{difficulty}",
          "subject": "{subject}",
          "starterCode": "Initial code template"
        }}"""

        # Call the Together API with streaming disabled
        response = client.chat.completions.create(
            model="meta-llama/Llama-3.3-70B-Instruct-Turbo-Free",
            messages=[{"role": "system", "content": prompt}],
            max_tokens=512,
            temperature=0.7,
            top_p=0.7,
            top_k=50,
            repetition_penalty=1,
            stop=["<|eot_id|>", "<|eom_id|>"],
            stream=False
        )

        # Extract content from the response
        content = response.choices[0].message.content if response.choices else ""

        if not content:
            return jsonify({"error": "No content generated by the model"}), 500

        # Strip the code block formatting (if any) from the content
        if content.startswith("```json"):
            content = content[7:-3].strip()  # Remove "```json" and trailing "```"

        return jsonify({"content": content})

    except Exception as e:
        return jsonify({"error": str(e)}), 500


@app.route('/api/evaluate-code', methods=['POST'])
def evaluate_code():
    try:
        # Input validation
        if not request.is_json:
            return jsonify({"error": "Request must be JSON"}), 400

        data = request.json
        if not all(key in data for key in ['task', 'code']):
            return jsonify({"error": "Missing required fields"}), 400

        task = data['task']
        code = data['code']
        css_code = data.get('cssCode', '')

        # Prepare the CSS code block if present
        css_code_block = f"\nCSS Code:\n{css_code}" if css_code else ""

        # Construct the prompt with proper escaping
        json_structure = {
            "score": "<number between 0 and 100>",
            "feedback": "detailed explanation of the evaluation",
            "suggestions": ["improvement point 1", "improvement point 2"],
            "solution": "correct implementation of the task"
        }

        prompt = f"""
        Evaluate this {task['subject']} code for the following task:
        Task: {task['title']}
        Description: {task['description']}

        Student's Code:
        {code}
        {css_code_block}

        Provide feedback in JSON format with exactly this structure:
        {json.dumps(json_structure, indent=2)}
        """

        # Simulate API call (replace with actual API call in production)
        response = client.chat.completions.create(
            model="meta-llama/Llama-3.3-70B-Instruct-Turbo-Free",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.7,
            top_p=0.7,
            top_k=50,
            repetition_penalty=1,
            stop=["<|eot_id|>", "<|eom_id|>"],
            stream=False
        )

        # Extract and process the response
        raw_content = response.choices[0].message.content if response.choices else ""
        if not raw_content:
            return jsonify({"error": "No content generated by the model"}), 500

        # Clean up the response
        def clean_response(content):
            # Remove code block markers
            content = re.sub(r'^```(?:json)?\s*|\s*```$', '', content.strip())
            
            # Normalize newlines and escape sequences
            content = content.replace('\r\n', '\n').replace('\r', '\n')
            
            # Remove any leading/trailing whitespace from each line
            content = '\n'.join(line.strip() for line in content.split('\n'))
            
            return content

        cleaned_content = clean_response(raw_content)

        try:
            # Parse the JSON response
            evaluation_data = json.loads(cleaned_content)

            # Validate required fields
            required_keys = ["score", "feedback", "suggestions", "solution"]
            missing_keys = [key for key in required_keys if key not in evaluation_data]
            
            if missing_keys:
                return jsonify({
                    "error": f"Missing required fields: {', '.join(missing_keys)}",
                    "content": cleaned_content
                }), 500

            # Validate data types
            if not isinstance(evaluation_data["score"], (int, float, str)):
                evaluation_data["score"] = str(evaluation_data["score"])
            if not isinstance(evaluation_data["suggestions"], list):
                evaluation_data["suggestions"] = [evaluation_data["suggestions"]]
            
            # Clean up the solution field
            if isinstance(evaluation_data["solution"], str):
                evaluation_data["solution"] = evaluation_data["solution"].strip()

            return jsonify(evaluation_data)

        except json.JSONDecodeError as e:
            # Provide detailed error information for JSON parsing failures
            return jsonify({
                "error": "Failed to parse JSON from the model's response",
                "details": str(e),
                "content": cleaned_content,
                "position": f"Error at character {e.pos}: {e.msg}"
            }), 500

    except Exception as e:
        # Handle unexpected errors with detailed information
        return jsonify({
            "error": "Internal server error",
            "details": str(e),
            "type": type(e).__name__
        }), 500
if __name__ == '__main__':
    app.run(port=3000,debug=True)